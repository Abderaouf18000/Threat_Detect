import mysql.connector
import re
import json
import os

def clean_description(description):
    """
    Nett descrip
    """
    return ' '.join(description.split())

def extract_relevant_keywords(text):
    """
    Extrait les mots-clés pertinents d'un texte en tenant compte du contexte.
    Supprime les mots courts, les caractères spéciaux, et garde les termes importants.
    """
    if not text:
        return []

    # Nettoyage initial
    cleaned_text = re.sub(r'[^\w\s]', '', text)  # Supprime les caractères spéciaux
    keywords = cleaned_text.split()

    # Liste des mots à ignorer (non significatifs pour la recherche)
    stop_words = {'de', 'la', 'le', 'les', 'et', 'ou', 'un', 'une', 'en', 'avec', 'dans', 'du', 'des', 'pour', 'par'}

    # Filtrage des mots-clés pertinents
    return [kw.lower() for kw in keywords if len(kw) > 2 and kw.lower() not in stop_words]

def search_vulnerability_by_object_parts(object_name, os, output_file):
    """
    Recherche des vulnérabilités dans la base de données qui contiennent soit le mot principal du modèle,
    soit les mots-clés du système d'exploitation.

    :param object_name: Nom de l'objet (modèle) pour lequel chercher des vulnérabilités.
    :param os: Système d'exploitation exact de l'objet (inclut la version).
    :param output_file: Fichier JSON dans lequel sauvegarder les résultats.
    """

    model_keyword = object_name.split()[0]  # Prendre le premier mot
    if not model_keyword:
        print("Erreur : Le mot-clé du modèle ne peut pas être vide.")
        return

    sql_where_clauses = []
    search_terms = []


    sql_model_clause = "description LIKE %s"
    sql_where_clauses.append(f"({sql_model_clause})")
    search_terms.append(f"%{model_keyword}%")

    sql_os_clause = "description LIKE %s"
    sql_where_clauses.append(f"({sql_os_clause})")
    search_terms.append(f"%{os}%")

    sql_where_clause = " OR ".join(sql_where_clauses)

    # Connexion à la base de données MySQL
    conn = mysql.connector.connect(
        host="localhost",
        user="root",
        password="Root@1234",
        database="vulnerabilities_db"
    )
    cursor = conn.cursor()

    # Requête SQL avec les filtres dynamiques
    search_query = f"""
    SELECT id, cve_id, description, cvss_v2_score, cvss_v2_vector,
           cvss_v3_score, cvss_v3_vector, cvss_v4_score, cvss_v4_vector,
           vuln_status, created_at, last_modified_at
    FROM vulnerabilities
    WHERE ({sql_where_clause})
        AND NOT ((cvss_v2_score IS NULL OR cvss_v2_score = '' OR cvss_v2_score = '0')
            AND (cvss_v3_score IS NULL OR cvss_v3_score = '' OR cvss_v3_score = '0')
            AND (cvss_v4_score IS NULL OR cvss_v4_score = '' OR cvss_v4_score = '0'))
    ORDER BY last_modified_at DESC;
    """

    # Exécuter la requête SQL
    try:
        print("Requête SQL générée :", search_query)
        print("Paramètres :", search_terms)

        cursor.execute(search_query, search_terms)
        results = cursor.fetchall()

        matched_results = []
        unique_descriptions = set()

        for row in results:
            cleaned_description = clean_description(row[2])
            if cleaned_description not in unique_descriptions:
                result_dict = {
                    "ID": row[0],
                    "CVE ID": row[1],
                    "Description": cleaned_description,
                    "CVSS v2 Score": row[3],
                    "CVSS v2 Vector": row[4],
                    "CVSS v3 Score": row[5],
                    "CVSS v3 Vector": row[6],
                    "CVSS v4 Score": row[7],
                    "CVSS v4 Vector": row[8],
                    "Status": row[9],
                    "Created At": str(row[10]),
                    "Last Modified At": str(row[11])
                }
                matched_results.append(result_dict)
                unique_descriptions.add(cleaned_description)

        if matched_results:
            with open(output_file, 'w', encoding='utf-8') as json_file:
                json.dump(matched_results, json_file, indent=4, ensure_ascii=False)
            print(f"Résultats écrits dans {output_file}.")
        else:
            print("Aucune vulnérabilité trouvée.")

    except mysql.connector.Error as e:
        print("Erreur MySQL :", e)
    finally:
        cursor.close()
        conn.close()



#---------------affichier les vulnérabilité par modél-------------
def process_vulnerabilities_for_models():
    """
    Récupère tous les modèles et leurs OS de la table 'devices', puis effectue une recherche
    de vulnérabilités pour chaque périphérique (en utilisant l'ID pour éviter les doublons)
    et écrit les résultats dans des fichiers JSON dans le dossier 'liste_vulnerabilite_json'.
    Les modèles où l'OS est 'Unknown OS' ou similaire sont exclus.
    """
    import os
    import mysql.connector
    import re

    # Connexion à la base de données MySQL
    conn = mysql.connector.connect(
        host="localhost",
        user="root",
        password="Root@1234",
        database="vulnerabilities_db"
    )
    cursor = conn.cursor()

    output_directory = "liste_vulnerabilite_json"
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    try:
        cursor.execute("SELECT id, model, os FROM devices WHERE model IS NOT NULL AND model != ''")
        devices_data = cursor.fetchall()

        for device_id, model, operating_system in devices_data:

            cleaned_model = model.strip() if model else "Unknown"
            cleaned_os = operating_system.strip() if operating_system else "Unknown OS"

            if cleaned_os.lower() in ["unknown", "unknown os", ""]:
                print(f"Modèle ignoré : {cleaned_model} (OS inconnu)")
                continue

            output_file = os.path.join(output_directory, f"{device_id}.json")

            print(f"Traitement du modèle : {cleaned_model} avec OS : {cleaned_os} (ID : {device_id})")

            search_vulnerability_by_object_parts(cleaned_model, cleaned_os, output_file)

    except mysql.connector.Error as e:
        print(f"Erreur lors de la récupération des modèles ou du traitement : {e}")
    finally:

        cursor.close()
        conn.close()



#--------------Vider le dossier contient des vulnéérabilit----------
def clean_vulnerability_json_folder():
    """
    Vide le dossier 'liste_vulnerabilite_json' en supprimant tous les fichiers qu'il contient.
    """
    # Chemin du dossier à vider
    folder_path = "liste_vulnerabilite_json"

    # Vérifier si le dossier existe
    if not os.path.exists(folder_path):
        print(f"Le dossier '{folder_path}' n'existe pas. Aucune action requise.")
        return

    # Parcourir tous les fichiers du dossier
    for filename in os.listdir(folder_path):
        file_path = os.path.join(folder_path, filename)
        try:
            # Supprimer uniquement les fichiers
            if os.path.isfile(file_path):
                os.remove(file_path)
                print(f"Fichier supprimé : {file_path}")
        except Exception as e:
            print(f"Erreur lors de la suppression du fichier {file_path} : {e}")

    print(f"Le dossier '{folder_path}' a été vidé avec succès.")

# Clean null score
def remove_null_scores_vulnerabilities(json_file):
    """
    Supprime toutes les vulnérabilités d'un fichier JSON où tous les scores CVSS (v2, v3, v4) sont null.

    :param json_file: Chemin vers le fichier JSON à traiter.
    """
    try:
        # Charger le fichier JSON
        with open(json_file, 'r', encoding='utf-8') as file:
            vulnerabilities = json.load(file)

        # Filtrer les vulnérabilités
        filtered_vulnerabilities = [
            vuln for vuln in vulnerabilities
            if not (
                vuln.get("CVSS v2 Score") is None and
                vuln.get("CVSS v3 Score") is None and
                vuln.get("CVSS v4 Score") is None
            )
        ]

        # Réécrire le fichier avec les données filtrées
        with open(json_file, 'w', encoding='utf-8') as file:
            json.dump(filtered_vulnerabilities, file, indent=4, ensure_ascii=False)

        print(f"Traitement terminé. Fichier mis à jour : {json_file}")
        print(f"Vulnérabilités restantes : {len(filtered_vulnerabilities)}")
    except FileNotFoundError:
        print(f"Le fichier {json_file} est introuvable.")
    except json.JSONDecodeError:
        print(f"Le fichier {json_file} contient des données JSON invalides.")
    except Exception as e:
        print(f"Une erreur est survenue : {e}")

#nbr vul dans chaque fichier
def count_vulnerabilities_in_json_file(json_file):
    """
    Compte le nombre de vulnérabilités dans un fichier JSON donné.

    :param json_file: Chemin vers le fichier JSON.
    :return: Le nombre de vulnérabilités dans le fichier JSON, ou None si une erreur se produit.
    """
    try:
        # Vérifier si le fichier existe
        if not os.path.exists(json_file):
            print("Fichier introuvable. Vérifiez le chemin fourni.")
            return None

        # Charger le fichier JSON
        with open(json_file, 'r', encoding='utf-8') as file:
            data = json.load(file)

        # Vérifier si le contenu est une liste
        if isinstance(data, list):
            return len(data)
        else:
            print(f"Le fichier '{json_file}' ne contient pas une liste valide.")
            return 0

    except json.JSONDecodeError:
        print(f"Erreur : Le fichier '{json_file}' contient des données JSON invalides.")
        return None
    except Exception as e:
        print(f"Erreur lors de la lecture du fichier '{json_file}': {e}")
        return None

def calculate_average_vulnerability_score(json_file):
    """
    Calcule le score moyen des vulnérabilités dans un fichier JSON,
    en choisissant le score le plus récent disponible (v4 > v3 > v2).

    :param json_file: Chemin vers le fichier JSON contenant les vulnérabilités.
    :return: Score moyen ou None si aucun score valide n'est disponible.
    """
    try:
        # Charger les données du fichier JSON
        with open(json_file, 'r', encoding='utf-8') as file:
            vulnerabilities = json.load(file)

        # Liste pour stocker les scores valides
        scores = []

        # Parcourir chaque vulnérabilité
        for vuln in vulnerabilities:
            # Priorité des scores : v4 > v3 > v2
            score = (
                vuln.get("CVSS v4 Score") or
                vuln.get("CVSS v3 Score") or
                vuln.get("CVSS v2 Score")
            )

            # Vérifier si le score est valide
            if score is not None:
                try:
                    scores.append(float(score))
                except ValueError:
                    print(f"Score invalide ignoré : {score}")

        # Calculer et retourner la moyenne si des scores sont disponibles
        if scores:
            return sum(scores) / len(scores)
        else:
            print("Aucun score CVSS valide trouvé.")
            return None

    except FileNotFoundError:
        print(f"Fichier non trouvé : {json_file}")
        return None
    except json.JSONDecodeError:
        print(f"Erreur dans le fichier JSON : {json_file}")
        return None
    except Exception as e:
        print(f"Erreur inattendue : {e}")
        return None

import mysql.connector

import mysql.connector

def transfer_devices_to_devices_2():
    """
    Vider la table `devices_2`, puis transférer les informations de la table `devices` vers `devices_2`,
    tout en calculant `nbr_v` et `moy_score` pour chaque ligne, en ignorant les lignes où l'OS est 'Unknown',
    et en ajoutant les colonnes `type` et `model`.
    """
    try:
        # Connexion à la base de données MySQL
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="Root@1234",
            database="vulnerabilities_db"
        )
        cursor = conn.cursor()

        # Vider la table `devices_2`
        cursor.execute("TRUNCATE TABLE devices_2")
        print("Table devices_2 vidée avec succès.")

        # Requête pour récupérer toutes les données de la table `devices`
        cursor.execute("SELECT id, mac, ip, state, name, model, os, type FROM devices")
        devices_data = cursor.fetchall()

        # Parcourir chaque appareil et transférer les données
        for device in devices_data:
            device_id, mac, ip, state, name, model, os, device_type = device

            # Vérifier si l'OS est inconnu
            if not os or os.lower() in ["unknown", "unknown os", ""]:
                print(f"Ligne ignorée : Appareil ID {device_id}, OS : '{os}'")
                continue

            # Construire le chemin du fichier JSON basé sur l'ID
            json_file_path = f"liste_vulnerabilite_json/{device_id}.json"

            # Calculer le nombre de vulnérabilités et le score moyen
            nbr_v = count_vulnerabilities_in_json_file(json_file_path)
            moy_score = calculate_average_vulnerability_score(json_file_path)

            # Insérer les données dans la table `devices_2`
            insert_query = """
                INSERT INTO devices_2 (id,mac, ip, state, name, nbr_v, moy_score, type, model)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            cursor.execute(insert_query, (device_id, mac, ip, state, name, nbr_v, moy_score, device_type, model))
            print(f"Appareil ID {device_id} transféré avec succès.")

        # Valider les changements dans la base de données
        conn.commit()

    except mysql.connector.Error as e:
        print(f"Erreur MySQL : {e}")
    finally:
        # Fermer les connexions à la base de données
        if cursor:
            cursor.close()
        if conn:
            conn.close()


# Appeler la fonction principale
if __name__ == "__main__":
    clean_vulnerability_json_folder()
    process_vulnerabilities_for_models()
    transfer_devices_to_devices_2()
